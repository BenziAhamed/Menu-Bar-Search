/*
 * DO NOT EDIT.
 *
 * Generated by the protocol buffer compiler.
 * Source: MenuItem.proto
 *
 */

import Foundation

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: ProtobufAPIVersionCheck {
  struct _1: ProtobufAPIVersion_1 {}
  typealias Version = _1
}

struct MenuItemCache: Message {
  static let protoMessageName: String = "MenuItemCache"

  var timeout: Double = 0

  var created: Double = 0

  var unknownFields = UnknownStorage()

  init() {}

  mutating func decodeMessage<D: Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularDoubleField(value: &self.timeout)
      case 2: try decoder.decodeSingularDoubleField(value: &self.created)
      default: break
      }
    }
  }

  func traverse<V: Visitor>(visitor: inout V) throws {
    if self.timeout != 0 {
      try visitor.visitSingularDoubleField(value: self.timeout, fieldNumber: 1)
    }
    if self.created != 0 {
      try visitor.visitSingularDoubleField(value: self.created, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

struct MenuItemList: Message {
  static let protoMessageName: String = "MenuItemList"

  var items: [MenuItem] = []

  var unknownFields = UnknownStorage()

  init() {}

  mutating func decodeMessage<D: Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.items)
      default: break
      }
    }
  }

  func traverse<V: Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

struct MenuItem: Message {
  static let protoMessageName: String = "MenuItem"

  var pathIndices: String = String()

  var shortcut: String = String()

  var path: [String] = []

  var unknownFields = UnknownStorage()

  init() {}

  mutating func decodeMessage<D: Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.pathIndices)
      case 2: try decoder.decodeSingularStringField(value: &self.shortcut)
      case 3: try decoder.decodeRepeatedStringField(value: &self.path)
      default: break
      }
    }
  }

  func traverse<V: Visitor>(visitor: inout V) throws {
    if !self.pathIndices.isEmpty {
      try visitor.visitSingularStringField(value: self.pathIndices, fieldNumber: 1)
    }
    if !self.shortcut.isEmpty {
      try visitor.visitSingularStringField(value: self.shortcut, fieldNumber: 2)
    }
    if !self.path.isEmpty {
      try visitor.visitRepeatedStringField(value: self.path, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

struct AlfredResultList: Message {
  static let protoMessageName: String = "AlfredResultList"

  var items: [AlfredResultItem] = []

  var unknownFields = UnknownStorage()

  init() {}

  mutating func decodeMessage<D: Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.items)
      default: break
      }
    }
  }

  func traverse<V: Visitor>(visitor: inout V) throws {
    if !self.items.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.items, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

struct AlfredResultItem: Message {
  static let protoMessageName: String = "AlfredResultItem"

  var title: String {
    get {return _storage._title}
    set {_uniqueStorage()._title = newValue}
  }

  var subtitle: String {
    get {return _storage._subtitle}
    set {_uniqueStorage()._subtitle = newValue}
  }

  var arg: String {
    get {return _storage._arg}
    set {_uniqueStorage()._arg = newValue}
  }

  var uid: String {
    get {return _storage._uid}
    set {_uniqueStorage()._uid = newValue}
  }

  var autoComplete: String {
    get {return _storage._autoComplete}
    set {_uniqueStorage()._autoComplete = newValue}
  }

  var valid: Bool {
    get {return _storage._valid}
    set {_uniqueStorage()._valid = newValue}
  }

  var icon: AlfredResultItemIcon {
    get {return _storage._icon ?? AlfredResultItemIcon()}
    set {_uniqueStorage()._icon = newValue}
  }
  var hasIcon: Bool {
    return _storage._icon != nil
  }
  mutating func clearIcon() {
    _storage._icon = nil
  }

  var unknownFields = UnknownStorage()

  init() {}

  mutating func decodeMessage<D: Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._title)
        case 2: try decoder.decodeSingularStringField(value: &_storage._subtitle)
        case 3: try decoder.decodeSingularStringField(value: &_storage._arg)
        case 4: try decoder.decodeSingularStringField(value: &_storage._uid)
        case 5: try decoder.decodeSingularStringField(value: &_storage._autoComplete)
        case 6: try decoder.decodeSingularBoolField(value: &_storage._valid)
        case 7: try decoder.decodeSingularMessageField(value: &_storage._icon)
        default: break
        }
      }
    }
  }

  func traverse<V: Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._title.isEmpty {
        try visitor.visitSingularStringField(value: _storage._title, fieldNumber: 1)
      }
      if !_storage._subtitle.isEmpty {
        try visitor.visitSingularStringField(value: _storage._subtitle, fieldNumber: 2)
      }
      if !_storage._arg.isEmpty {
        try visitor.visitSingularStringField(value: _storage._arg, fieldNumber: 3)
      }
      if !_storage._uid.isEmpty {
        try visitor.visitSingularStringField(value: _storage._uid, fieldNumber: 4)
      }
      if !_storage._autoComplete.isEmpty {
        try visitor.visitSingularStringField(value: _storage._autoComplete, fieldNumber: 5)
      }
      if _storage._valid != false {
        try visitor.visitSingularBoolField(value: _storage._valid, fieldNumber: 6)
      }
      if let v = _storage._icon {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  fileprivate var _storage = _StorageClass()
}

struct AlfredResultItemIcon: Message {
  static let protoMessageName: String = "AlfredResultItemIcon"

  var type: String = String()

  var path: String = String()

  var unknownFields = UnknownStorage()

  init() {}

  mutating func decodeMessage<D: Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.type)
      case 2: try decoder.decodeSingularStringField(value: &self.path)
      default: break
      }
    }
  }

  func traverse<V: Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

struct Settings: Message {
  static let protoMessageName: String = "Settings"

  var appFilters: [AppFilter] = []

  var unknownFields = UnknownStorage()

  init() {}

  mutating func decodeMessage<D: Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.appFilters)
      default: break
      }
    }
  }

  func traverse<V: Visitor>(visitor: inout V) throws {
    if !self.appFilters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.appFilters, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

struct AppFilter: Message {
  static let protoMessageName: String = "AppFilter"

  var app: String = String()

  var ignoreMenuPaths: [MenuPath] = []

  var showDisabledMenuItems: Bool = false

  var showAppleMenu: Bool = false

  var cacheDuration: Double = 0

  var disabled: Bool = false

  var unknownFields = UnknownStorage()

  init() {}

  mutating func decodeMessage<D: Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.app)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.ignoreMenuPaths)
      case 3: try decoder.decodeSingularBoolField(value: &self.showDisabledMenuItems)
      case 4: try decoder.decodeSingularBoolField(value: &self.showAppleMenu)
      case 5: try decoder.decodeSingularDoubleField(value: &self.cacheDuration)
      case 6: try decoder.decodeSingularBoolField(value: &self.disabled)
      default: break
      }
    }
  }

  func traverse<V: Visitor>(visitor: inout V) throws {
    if !self.app.isEmpty {
      try visitor.visitSingularStringField(value: self.app, fieldNumber: 1)
    }
    if !self.ignoreMenuPaths.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.ignoreMenuPaths, fieldNumber: 2)
    }
    if self.showDisabledMenuItems != false {
      try visitor.visitSingularBoolField(value: self.showDisabledMenuItems, fieldNumber: 3)
    }
    if self.showAppleMenu != false {
      try visitor.visitSingularBoolField(value: self.showAppleMenu, fieldNumber: 4)
    }
    if self.cacheDuration != 0 {
      try visitor.visitSingularDoubleField(value: self.cacheDuration, fieldNumber: 5)
    }
    if self.disabled != false {
      try visitor.visitSingularBoolField(value: self.disabled, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

struct MenuPath: Message {
  static let protoMessageName: String = "MenuPath"

  var path: [String] = []

  var unknownFields = UnknownStorage()

  init() {}

  mutating func decodeMessage<D: Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedStringField(value: &self.path)
      default: break
      }
    }
  }

  func traverse<V: Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitRepeatedStringField(value: self.path, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension MenuItemCache: _MessageImplementationBase, _ProtoNameProviding {
  static let _protobuf_nameMap: _NameMap = [
    1: .same(proto: "timeout"),
    2: .same(proto: "created"),
  ]

  func _protobuf_generated_isEqualTo(other: MenuItemCache) -> Bool {
    if self.timeout != other.timeout {return false}
    if self.created != other.created {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension MenuItemList: _MessageImplementationBase, _ProtoNameProviding {
  static let _protobuf_nameMap: _NameMap = [
    1: .same(proto: "items"),
  ]

  func _protobuf_generated_isEqualTo(other: MenuItemList) -> Bool {
    if self.items != other.items {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension MenuItem: _MessageImplementationBase, _ProtoNameProviding {
  static let _protobuf_nameMap: _NameMap = [
    1: .same(proto: "pathIndices"),
    2: .same(proto: "shortcut"),
    3: .same(proto: "path"),
  ]

  func _protobuf_generated_isEqualTo(other: MenuItem) -> Bool {
    if self.pathIndices != other.pathIndices {return false}
    if self.shortcut != other.shortcut {return false}
    if self.path != other.path {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension AlfredResultList: _MessageImplementationBase, _ProtoNameProviding {
  static let _protobuf_nameMap: _NameMap = [
    1: .same(proto: "items"),
  ]

  func _protobuf_generated_isEqualTo(other: AlfredResultList) -> Bool {
    if self.items != other.items {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension AlfredResultItem: _MessageImplementationBase, _ProtoNameProviding {
  static let _protobuf_nameMap: _NameMap = [
    1: .same(proto: "title"),
    2: .same(proto: "subtitle"),
    3: .same(proto: "arg"),
    4: .same(proto: "uid"),
    5: .unique(proto: "autoComplete", json: "autocomplete"),
    6: .same(proto: "valid"),
    7: .same(proto: "icon"),
  ]

  fileprivate class _StorageClass {
    var _title: String = String()
    var _subtitle: String = String()
    var _arg: String = String()
    var _uid: String = String()
    var _autoComplete: String = String()
    var _valid: Bool = false
    var _icon: AlfredResultItemIcon? = nil

    init() {}

    init(copying source: _StorageClass) {
      _title = source._title
      _subtitle = source._subtitle
      _arg = source._arg
      _uid = source._uid
      _autoComplete = source._autoComplete
      _valid = source._valid
      _icon = source._icon
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  func _protobuf_generated_isEqualTo(other: AlfredResultItem) -> Bool {
    if _storage !== other._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((_storage, other._storage)) { (_storage, other_storage) in
        if _storage._title != other_storage._title {return false}
        if _storage._subtitle != other_storage._subtitle {return false}
        if _storage._arg != other_storage._arg {return false}
        if _storage._uid != other_storage._uid {return false}
        if _storage._autoComplete != other_storage._autoComplete {return false}
        if _storage._valid != other_storage._valid {return false}
        if _storage._icon != other_storage._icon {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension AlfredResultItemIcon: _MessageImplementationBase, _ProtoNameProviding {
  static let _protobuf_nameMap: _NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "path"),
  ]

  func _protobuf_generated_isEqualTo(other: AlfredResultItemIcon) -> Bool {
    if self.type != other.type {return false}
    if self.path != other.path {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension Settings: _MessageImplementationBase, _ProtoNameProviding {
  static let _protobuf_nameMap: _NameMap = [
    1: .same(proto: "appFilters"),
  ]

  func _protobuf_generated_isEqualTo(other: Settings) -> Bool {
    if self.appFilters != other.appFilters {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension AppFilter: _MessageImplementationBase, _ProtoNameProviding {
  static let _protobuf_nameMap: _NameMap = [
    1: .same(proto: "app"),
    2: .same(proto: "ignoreMenuPaths"),
    3: .same(proto: "showDisabledMenuItems"),
    4: .same(proto: "showAppleMenu"),
    5: .same(proto: "cacheDuration"),
    6: .same(proto: "disabled"),
  ]

  func _protobuf_generated_isEqualTo(other: AppFilter) -> Bool {
    if self.app != other.app {return false}
    if self.ignoreMenuPaths != other.ignoreMenuPaths {return false}
    if self.showDisabledMenuItems != other.showDisabledMenuItems {return false}
    if self.showAppleMenu != other.showAppleMenu {return false}
    if self.cacheDuration != other.cacheDuration {return false}
    if self.disabled != other.disabled {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}

extension MenuPath: _MessageImplementationBase, _ProtoNameProviding {
  static let _protobuf_nameMap: _NameMap = [
    1: .same(proto: "path"),
  ]

  func _protobuf_generated_isEqualTo(other: MenuPath) -> Bool {
    if self.path != other.path {return false}
    if unknownFields != other.unknownFields {return false}
    return true
  }
}
